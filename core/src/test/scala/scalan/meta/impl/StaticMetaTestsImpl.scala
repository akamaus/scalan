package scalan.meta

import scala.reflect.runtime.universe.{WeakTypeTag, weakTypeTag}
import scalan.meta.ScalanAst._

package impl {
// Abs -----------------------------------
trait StaticMetaTestsAbs extends scalan.ScalanDsl with StaticMetaTests {
  self: StaticMetaTestsDsl =>

  // single proxy for each type family
  implicit def proxyMetaTest(p: Rep[MetaTest]): MetaTest = {
    proxyOps[MetaTest](p)(scala.reflect.classTag[MetaTest])
  }

  // familyElem
  class MetaTestElem[To <: MetaTest]
    extends EntityElem[To] {
    lazy val parent: Option[Elem[_]] = None
    lazy val typeArgs = TypeArgs()
    override def isEntityType = true
    override lazy val tag = {
      weakTypeTag[MetaTest].asInstanceOf[WeakTypeTag[To]]
    }
    override def convert(x: Rep[Def[_]]) = {
      implicit val eTo: Elem[To] = this
      val conv = fun {x: Rep[MetaTest] => convertMetaTest(x) }
      tryConvert(element[MetaTest], this, x, conv)
    }

    def convertMetaTest(x: Rep[MetaTest]): Rep[To] = {
      x.selfType1 match {
        case _: MetaTestElem[_] => x.asRep[To]
        case e => !!!(s"Expected $x to have MetaTestElem[_], but got $e", x)
      }
    }

    override def getDefaultRep: Rep[To] = ???
  }

  implicit def metaTestElement: Elem[MetaTest] =
    cachedElem[MetaTestElem[MetaTest]]()

  implicit case object MetaTestCompanionElem extends CompanionElem[MetaTestCompanionAbs] {
    lazy val tag = weakTypeTag[MetaTestCompanionAbs]
    protected def getDefaultRep = MetaTest
  }

  abstract class MetaTestCompanionAbs extends CompanionDef[MetaTestCompanionAbs] {
    def selfType = MetaTestCompanionElem
    override def toString = "MetaTest"
  }
  def MetaTest: Rep[MetaTestCompanionAbs]
  implicit def proxyMetaTestCompanionAbs(p: Rep[MetaTestCompanionAbs]): MetaTestCompanionAbs =
    proxyOps[MetaTestCompanionAbs](p)

  abstract class AbsMTWithStaticData
      (f1: Rep[Int], f2: Int, f3: Rep[Double])
    extends MTWithStaticData(f1, f2, f3) with Def[MTWithStaticData] {
    lazy val selfType = element[MTWithStaticData]
  }
  // elem for concrete class
  class MTWithStaticDataElem(val iso: Iso[MTWithStaticDataData, MTWithStaticData])
    extends MetaTestElem[MTWithStaticData]
    with ConcreteElem[MTWithStaticDataData, MTWithStaticData] {
    override lazy val parent: Option[Elem[_]] = Some(metaTestElement)
    override lazy val typeArgs = TypeArgs()

    override def convertMetaTest(x: Rep[MetaTest]) = // Converter is not generated by meta
!!!("Cannot convert from MetaTest to MTWithStaticData: missing fields List(f1, f2, f3)")
    override def getDefaultRep = MTWithStaticData(0, scalan.common.Default.defaultOf[Int], 0.0)
    override lazy val tag = {
      weakTypeTag[MTWithStaticData]
    }
  }

  // state representation type
  type MTWithStaticDataData = (Int, (Int, Double))

  // 3) Iso for concrete class
  class MTWithStaticDataIso
    extends EntityIso[MTWithStaticDataData, MTWithStaticData] with Def[MTWithStaticDataIso] {
    override def from(p: Rep[MTWithStaticData]) =
      Pair(p.f1, Pair(p.f2, p.f3))
    override def to(p: Rep[(Int, (Int, Double))]) = {
      val Pair(f1, Pair(f2, f3)) = p
      MTWithStaticData(f1, valueFromRep(f2), f3)
    }
    lazy val eFrom = pairElement(element[Int], pairElement(element[Int], element[Double]))
    lazy val eTo = new MTWithStaticDataElem(self)
    lazy val selfType = new MTWithStaticDataIsoElem
    def productArity = 0
    def productElement(n: Int) = ???
  }
  case class MTWithStaticDataIsoElem() extends Elem[MTWithStaticDataIso] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new MTWithStaticDataIso())
    lazy val tag = {
      weakTypeTag[MTWithStaticDataIso]
    }
    lazy val typeArgs = TypeArgs()
  }
  // 4) constructor and deconstructor
  class MTWithStaticDataCompanionAbs extends CompanionDef[MTWithStaticDataCompanionAbs] {
    def selfType = MTWithStaticDataCompanionElem
    override def toString = "MTWithStaticData"
    @scalan.OverloadId("fromData")
    def apply(p: Rep[MTWithStaticDataData]): Rep[MTWithStaticData] =
      isoMTWithStaticData.to(p)
    @scalan.OverloadId("fromFields")
    def apply(f1: Rep[Int], f2: Int, f3: Rep[Double]): Rep[MTWithStaticData] =
      mkMTWithStaticData(f1, f2, f3)

    def unapply(p: Rep[MetaTest]) = unmkMTWithStaticData(p)
  }
  lazy val MTWithStaticDataRep: Rep[MTWithStaticDataCompanionAbs] = new MTWithStaticDataCompanionAbs
  lazy val MTWithStaticData: MTWithStaticDataCompanionAbs = proxyMTWithStaticDataCompanion(MTWithStaticDataRep)
  implicit def proxyMTWithStaticDataCompanion(p: Rep[MTWithStaticDataCompanionAbs]): MTWithStaticDataCompanionAbs = {
    proxyOps[MTWithStaticDataCompanionAbs](p)
  }

  implicit case object MTWithStaticDataCompanionElem extends CompanionElem[MTWithStaticDataCompanionAbs] {
    lazy val tag = weakTypeTag[MTWithStaticDataCompanionAbs]
    protected def getDefaultRep = MTWithStaticData
  }

  implicit def proxyMTWithStaticData(p: Rep[MTWithStaticData]): MTWithStaticData =
    proxyOps[MTWithStaticData](p)

  implicit class ExtendedMTWithStaticData(p: Rep[MTWithStaticData]) {
    def toData: Rep[MTWithStaticDataData] = isoMTWithStaticData.from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoMTWithStaticData: Iso[MTWithStaticDataData, MTWithStaticData] =
    reifyObject(new MTWithStaticDataIso())

  // 6) smart constructor and deconstructor
  def mkMTWithStaticData(f1: Rep[Int], f2: Int, f3: Rep[Double]): Rep[MTWithStaticData]
  def unmkMTWithStaticData(p: Rep[MetaTest]): Option[(Rep[Int], Int, Rep[Double])]

  abstract class AbsMTWithNonTypeDescImplicits[A]
      ()(implicit elem: Elem[A], o: Ordering[A], kp: KeyPath)
    extends MTWithNonTypeDescImplicits[A]() with Def[MTWithNonTypeDescImplicits[A]] {
    lazy val selfType = element[MTWithNonTypeDescImplicits[A]]
  }
  // elem for concrete class
  class MTWithNonTypeDescImplicitsElem[A](val iso: Iso[MTWithNonTypeDescImplicitsData[A], MTWithNonTypeDescImplicits[A]])(implicit val elem: Elem[A], val o: Ordering[A], val kp: KeyPath)
    extends MetaTestElem[MTWithNonTypeDescImplicits[A]]
    with ConcreteElem[MTWithNonTypeDescImplicitsData[A], MTWithNonTypeDescImplicits[A]] {
    override lazy val parent: Option[Elem[_]] = Some(metaTestElement)
    override lazy val typeArgs = TypeArgs("A" -> elem)

    override def convertMetaTest(x: Rep[MetaTest]) = MTWithNonTypeDescImplicits()
    override def getDefaultRep = MTWithNonTypeDescImplicits()
    override lazy val tag = {
      implicit val tagA = elem.tag
      weakTypeTag[MTWithNonTypeDescImplicits[A]]
    }
  }

  // state representation type
  type MTWithNonTypeDescImplicitsData[A] = Unit

  // 3) Iso for concrete class
  class MTWithNonTypeDescImplicitsIso[A](implicit elem: Elem[A], o: Ordering[A], kp: KeyPath)
    extends EntityIso[MTWithNonTypeDescImplicitsData[A], MTWithNonTypeDescImplicits[A]] with Def[MTWithNonTypeDescImplicitsIso[A]] {
    override def from(p: Rep[MTWithNonTypeDescImplicits[A]]) =
      UNIT
    override def to(p: Rep[Unit]) = {
      val UNIT = p
      MTWithNonTypeDescImplicits()
    }
    lazy val eFrom = UnitElement
    lazy val eTo = new MTWithNonTypeDescImplicitsElem[A](self)
    lazy val selfType = new MTWithNonTypeDescImplicitsIsoElem[A](elem, o, kp)
    def productArity = 3
    def productElement(n: Int) = (elem, o, kp).productElement(n)
  }
  case class MTWithNonTypeDescImplicitsIsoElem[A](elem: Elem[A], o: Ordering[A], kp: KeyPath) extends Elem[MTWithNonTypeDescImplicitsIso[A]] {
    def isEntityType = true
    def getDefaultRep = reifyObject(new MTWithNonTypeDescImplicitsIso[A]()(elem, o, kp))
    lazy val tag = {
      implicit val tagA = elem.tag
      weakTypeTag[MTWithNonTypeDescImplicitsIso[A]]
    }
    lazy val typeArgs = TypeArgs("A" -> elem)
  }
  // 4) constructor and deconstructor
  class MTWithNonTypeDescImplicitsCompanionAbs extends CompanionDef[MTWithNonTypeDescImplicitsCompanionAbs] {
    def selfType = MTWithNonTypeDescImplicitsCompanionElem
    override def toString = "MTWithNonTypeDescImplicits"
    @scalan.OverloadId("fromData")
    def apply[A](p: Rep[MTWithNonTypeDescImplicitsData[A]])(implicit elem: Elem[A], o: Ordering[A], kp: KeyPath): Rep[MTWithNonTypeDescImplicits[A]] =
      isoMTWithNonTypeDescImplicits(elem, o, kp).to(p)
    @scalan.OverloadId("fromFields")
    def apply[A]()(implicit elem: Elem[A], o: Ordering[A], kp: KeyPath): Rep[MTWithNonTypeDescImplicits[A]] =
      mkMTWithNonTypeDescImplicits()

    def unapply[A](p: Rep[MetaTest]) = unmkMTWithNonTypeDescImplicits(p)
  }
  lazy val MTWithNonTypeDescImplicitsRep: Rep[MTWithNonTypeDescImplicitsCompanionAbs] = new MTWithNonTypeDescImplicitsCompanionAbs
  lazy val MTWithNonTypeDescImplicits: MTWithNonTypeDescImplicitsCompanionAbs = proxyMTWithNonTypeDescImplicitsCompanion(MTWithNonTypeDescImplicitsRep)
  implicit def proxyMTWithNonTypeDescImplicitsCompanion(p: Rep[MTWithNonTypeDescImplicitsCompanionAbs]): MTWithNonTypeDescImplicitsCompanionAbs = {
    proxyOps[MTWithNonTypeDescImplicitsCompanionAbs](p)
  }

  implicit case object MTWithNonTypeDescImplicitsCompanionElem extends CompanionElem[MTWithNonTypeDescImplicitsCompanionAbs] {
    lazy val tag = weakTypeTag[MTWithNonTypeDescImplicitsCompanionAbs]
    protected def getDefaultRep = MTWithNonTypeDescImplicits
  }

  implicit def proxyMTWithNonTypeDescImplicits[A](p: Rep[MTWithNonTypeDescImplicits[A]]): MTWithNonTypeDescImplicits[A] =
    proxyOps[MTWithNonTypeDescImplicits[A]](p)

  implicit class ExtendedMTWithNonTypeDescImplicits[A](p: Rep[MTWithNonTypeDescImplicits[A]])(implicit elem: Elem[A], o: Ordering[A], kp: KeyPath) {
    def toData: Rep[MTWithNonTypeDescImplicitsData[A]] = isoMTWithNonTypeDescImplicits(elem, o, kp).from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoMTWithNonTypeDescImplicits[A](implicit elem: Elem[A], o: Ordering[A], kp: KeyPath): Iso[MTWithNonTypeDescImplicitsData[A], MTWithNonTypeDescImplicits[A]] =
    reifyObject(new MTWithNonTypeDescImplicitsIso[A]()(elem, o, kp))

  // 6) smart constructor and deconstructor
  def mkMTWithNonTypeDescImplicits[A]()(implicit elem: Elem[A], o: Ordering[A], kp: KeyPath): Rep[MTWithNonTypeDescImplicits[A]]
  def unmkMTWithNonTypeDescImplicits[A](p: Rep[MetaTest]): Option[(Rep[Unit])]

  registerModule(StaticMetaTests_Module)
}

// Std -----------------------------------
trait StaticMetaTestsStd extends scalan.ScalanDslStd with StaticMetaTestsDsl {
  self: StaticMetaTestsDslStd =>
  lazy val MetaTest: Rep[MetaTestCompanionAbs] = new MetaTestCompanionAbs {
  }

  case class StdMTWithStaticData
      (override val f1: Rep[Int], override val f2: Int, override val f3: Rep[Double])
    extends AbsMTWithStaticData(f1, f2, f3) {
  }

  def mkMTWithStaticData
    (f1: Rep[Int], f2: Int, f3: Rep[Double]): Rep[MTWithStaticData] =
    new StdMTWithStaticData(f1, f2, f3)
  def unmkMTWithStaticData(p: Rep[MetaTest]) = p match {
    case p: MTWithStaticData @unchecked =>
      Some((p.f1, p.f2, p.f3))
    case _ => None
  }

  case class StdMTWithNonTypeDescImplicits[A]
      ()(implicit elem: Elem[A], o: Ordering[A], kp: KeyPath)
    extends AbsMTWithNonTypeDescImplicits[A]() {
  }

  def mkMTWithNonTypeDescImplicits[A]
    ()(implicit elem: Elem[A], o: Ordering[A], kp: KeyPath): Rep[MTWithNonTypeDescImplicits[A]] =
    new StdMTWithNonTypeDescImplicits[A]()
  def unmkMTWithNonTypeDescImplicits[A](p: Rep[MetaTest]) = p match {
    case p: MTWithNonTypeDescImplicits[A] @unchecked =>
      Some(())
    case _ => None
  }
}

// Exp -----------------------------------
trait StaticMetaTestsExp extends scalan.ScalanDslExp with StaticMetaTestsDsl {
  self: StaticMetaTestsDslExp =>
  lazy val MetaTest: Rep[MetaTestCompanionAbs] = new MetaTestCompanionAbs {
  }

  case class ExpMTWithStaticData
      (override val f1: Rep[Int], override val f2: Int, override val f3: Rep[Double])
    extends AbsMTWithStaticData(f1, f2, f3)

  object MTWithStaticDataMethods {
  }

  def mkMTWithStaticData
    (f1: Rep[Int], f2: Int, f3: Rep[Double]): Rep[MTWithStaticData] =
    new ExpMTWithStaticData(f1, f2, f3)
  def unmkMTWithStaticData(p: Rep[MetaTest]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: MTWithStaticDataElem @unchecked =>
      Some((p.asRep[MTWithStaticData].f1, p.asRep[MTWithStaticData].f2, p.asRep[MTWithStaticData].f3))
    case _ =>
      None
  }

  case class ExpMTWithNonTypeDescImplicits[A]
      ()(implicit elem: Elem[A], o: Ordering[A], kp: KeyPath)
    extends AbsMTWithNonTypeDescImplicits[A]()

  object MTWithNonTypeDescImplicitsMethods {
  }

  def mkMTWithNonTypeDescImplicits[A]
    ()(implicit elem: Elem[A], o: Ordering[A], kp: KeyPath): Rep[MTWithNonTypeDescImplicits[A]] =
    new ExpMTWithNonTypeDescImplicits[A]()
  def unmkMTWithNonTypeDescImplicits[A](p: Rep[MetaTest]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: MTWithNonTypeDescImplicitsElem[A] @unchecked =>
      Some(())
    case _ =>
      None
  }

  object MetaTestMethods {
  }
}

object StaticMetaTests_Module extends scalan.ModuleInfo {
  val dump = "H4sIAAAAAAAAALVWTYgcRRSu7pnZ+Vuy6+iKWZCs60TFn5k1i0RYJKyZiWycnRm2N26YBENNd81sJ9XdZXfNMuMhgocc1JOIB8FDQPESBPGmEAQVREJAr549xUjIwZwUX1X/TM+wvSYH+1BUVb96P9/73qu6dhtlPBc95emYYrtiEY4rmpyve7ys1W1u8tGmYwwoqZHeL8995xTe/aCpovkOmtnFXs2jHZT3J/Uhi+YaNxooj22deNxxPY6eaEgLVd2hlOjcdOyqaVkDjruUVBumx9caKN11jNFb6DJSGmhed2zdJZxoJyn2POIF+zkiPDKjdV6uRy02tmFXRRTVWBTbLjY5uA825n35LcK0ke3YI4ujQ4FrLSbcApkiGTKIYcNiVJpJNVDWtJjj8tBqFizsOka4TNsYNlCpcRHv4SpY7Vc17pp2XyhjWL+E+6QJIkI8DTF4hPa2R4wEyoseNybsDRlCCLJyTDpWGWNWiTCrCMzKGnFNTM23sfjZdp3hCPmfkkJoyEDF8/+hItRA6rZRfu+8fu6eVrRUcXgoXMlKh2ZA0ZEEhsj0ALY/bX3o3X3t6nEVFTqoYHrrXY+7WOdxGgRwFbFtO1z6HCGI3T5kcDkpg9LKOshM0SSvOxbDNmgKsJyFRFFTN7kQFnuzQXoSsM9yRkJRZciUKN6lhHgll05iStu3Dr9w9I/6WRWpkybyoFKDYnBDpRzlNkHLNoAgMRVDPoA32VAU8tO3/jR+XEHn1QioQO/95QZUlF7+5JujpP2linIdSeVTFPdllgQSNeLpHZRz9ojr72f3MBWzfTOVNUgPDygP8IsHnoLAOVpKrEJGBCprkt1KGH7RJ2jTsUn5VLv8l/bzR9cE/1w06//xy/If8/jfvx3qcUlNjtTei9KhOY5SUMsREk8mZY2Rtmta0Dn2yEvff3vmzvVmRiauFITzBqYD4hdtEM04MmFQWQFLGzb3cyftLURhiGFROHVMzJaS/q7u47IYj8DOSgUMzNScARTmmB8BS6QGKVqSa47mN7d3TL6ridzoNcyxFBlXbFGJ6Z87iIBjrdOmYhoWlKlg0oQSK1SeroeLyJ6yHjO0vwrFiZxruQYRyD+wDvUSC6Wzr5NRG/Pd2BmOFn2YgFwh0TeC9uCNAxW8eTyZN1A/j241HqG3T1xXUeY0yvSgNLwGynSdgW2EbQeuK06G/NVwT5ksDWgz2MVWWLl+k15C46xNhRsL+qACDy+2r65cWbjz2YWHZfPNdU1uYVZeeYDWG3bK/7G1osnspsDt++PoQUyd7q2LU2dbfppdVPCbieZY5KHlu+abV9/nsp8qw8l7u9W9CPfkmjx8GM5VEpCvEZ1ilxiCT8SCR4WP6erHJ3ZOP7ZzRuqeNaSQ/ydqjPs/gTYxW5MX9jMHXNggVK5bDB5kMFn94ZVf37nxxeeyI45h4WjO7wohLGC5GAtCwngWDC0nRKYFWYT8XL73afPZm1//LjtlQfABurQdvYLiHXIylaUpF+B1M1GXaUGVwBMxnhPDhX8BkVaWzIwKAAA="
}
}

trait StaticMetaTestsDsl extends impl.StaticMetaTestsAbs
trait StaticMetaTestsDslStd extends impl.StaticMetaTestsStd
trait StaticMetaTestsDslExp extends impl.StaticMetaTestsExp
