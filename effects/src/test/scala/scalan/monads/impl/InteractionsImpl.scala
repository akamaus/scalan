package scalan.monads

import scala.io.StdIn
import scala.reflect.runtime.universe._
import scalan._
import scalan.monads._
import scala.reflect.runtime.universe.{WeakTypeTag, weakTypeTag}
import scalan.meta.ScalanAst._

package impl {
// Abs -----------------------------------
trait InteractionsAbs extends scalan.ScalanDsl with Interactions {
  self: InteractionsDsl =>

  // single proxy for each type family
  implicit def proxyInteract[A](p: Rep[Interact[A]]): Interact[A] = {
    proxyOps[Interact[A]](p)(scala.reflect.classTag[Interact[A]])
  }

  // familyElem
  class InteractElem[A, To <: Interact[A]](implicit _eA: Elem[A])
    extends EntityElem[To] {
    def eA = _eA
    lazy val parent: Option[Elem[_]] = None
    lazy val typeArgs = TypeArgs("A" -> (eA -> scalan.util.Invariant))
    override lazy val tag = {
      implicit val tagA = eA.tag
      weakTypeTag[Interact[A]].asInstanceOf[WeakTypeTag[To]]
    }
    override def convert(x: Rep[Def[_]]) = {
      implicit val eTo: Elem[To] = this
      val conv = fun {x: Rep[Interact[A]] => convertInteract(x) }
      tryConvert(element[Interact[A]], this, x, conv)
    }

    def convertInteract(x: Rep[Interact[A]]): Rep[To] = {
      x.selfType1 match {
        case _: InteractElem[_, _] => x.asRep[To]
        case e => !!!(s"Expected $x to have InteractElem[_, _], but got $e", x)
      }
    }

    override def getDefaultRep: Rep[To] = ???
  }

  implicit def interactElement[A](implicit eA: Elem[A]): Elem[Interact[A]] =
    cachedElem[InteractElem[A, Interact[A]]](eA)

  implicit case object InteractCompanionElem extends CompanionElem[InteractCompanionAbs] {
    lazy val tag = weakTypeTag[InteractCompanionAbs]
    protected def getDefaultRep = Interact
  }

  abstract class InteractCompanionAbs extends CompanionDef[InteractCompanionAbs] with InteractCompanion {
    def selfType = InteractCompanionElem
    override def toString = "Interact"
  }
  def Interact: Rep[InteractCompanionAbs]
  implicit def proxyInteractCompanionAbs(p: Rep[InteractCompanionAbs]): InteractCompanionAbs =
    proxyOps[InteractCompanionAbs](p)

  abstract class AbsAsk
      (prompt: Rep[String])
    extends Ask(prompt) with Def[Ask] {
    lazy val selfType = element[Ask]
  }
  // elem for concrete class
  class AskElem(val iso: Iso[AskData, Ask])
    extends InteractElem[String, Ask]
    with ConcreteElem[AskData, Ask] {
    override lazy val parent: Option[Elem[_]] = Some(interactElement(StringElement))
    override lazy val typeArgs = TypeArgs()

    override def convertInteract(x: Rep[Interact[String]]) = // Converter is not generated by meta
!!!("Cannot convert from Interact to Ask: missing fields List(prompt)")
    override def getDefaultRep = Ask("")
    override lazy val tag = {
      weakTypeTag[Ask]
    }
  }

  // state representation type
  type AskData = String

  // 3) Iso for concrete class
  class AskIso
    extends EntityIso[AskData, Ask] with Def[AskIso] {
    override def from(p: Rep[Ask]) =
      p.prompt
    override def to(p: Rep[String]) = {
      val prompt = p
      Ask(prompt)
    }
    lazy val eFrom = element[String]
    lazy val eTo = new AskElem(self)
    lazy val selfType = new AskIsoElem
    def productArity = 0
    def productElement(n: Int) = ???
  }
  case class AskIsoElem() extends Elem[AskIso] {
    def getDefaultRep = reifyObject(new AskIso())
    lazy val tag = {
      weakTypeTag[AskIso]
    }
    lazy val typeArgs = TypeArgs()
  }
  // 4) constructor and deconstructor
  class AskCompanionAbs extends CompanionDef[AskCompanionAbs] with AskCompanion {
    def selfType = AskCompanionElem
    override def toString = "Ask"

    @scalan.OverloadId("fromFields")
    def apply(prompt: Rep[String]): Rep[Ask] =
      mkAsk(prompt)

    def unapply(p: Rep[Interact[String]]) = unmkAsk(p)
  }
  lazy val AskRep: Rep[AskCompanionAbs] = new AskCompanionAbs
  lazy val Ask: AskCompanionAbs = proxyAskCompanion(AskRep)
  implicit def proxyAskCompanion(p: Rep[AskCompanionAbs]): AskCompanionAbs = {
    proxyOps[AskCompanionAbs](p)
  }

  implicit case object AskCompanionElem extends CompanionElem[AskCompanionAbs] {
    lazy val tag = weakTypeTag[AskCompanionAbs]
    protected def getDefaultRep = Ask
  }

  implicit def proxyAsk(p: Rep[Ask]): Ask =
    proxyOps[Ask](p)

  implicit class ExtendedAsk(p: Rep[Ask]) {
    def toData: Rep[AskData] = isoAsk.from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoAsk: Iso[AskData, Ask] =
    reifyObject(new AskIso())

  // 6) smart constructor and deconstructor
  def mkAsk(prompt: Rep[String]): Rep[Ask]
  def unmkAsk(p: Rep[Interact[String]]): Option[(Rep[String])]

  abstract class AbsTell
      (msg: Rep[String])
    extends Tell(msg) with Def[Tell] {
    lazy val selfType = element[Tell]
  }
  // elem for concrete class
  class TellElem(val iso: Iso[TellData, Tell])
    extends InteractElem[Unit, Tell]
    with ConcreteElem[TellData, Tell] {
    override lazy val parent: Option[Elem[_]] = Some(interactElement(UnitElement))
    override lazy val typeArgs = TypeArgs()

    override def convertInteract(x: Rep[Interact[Unit]]) = // Converter is not generated by meta
!!!("Cannot convert from Interact to Tell: missing fields List(msg)")
    override def getDefaultRep = Tell("")
    override lazy val tag = {
      weakTypeTag[Tell]
    }
  }

  // state representation type
  type TellData = String

  // 3) Iso for concrete class
  class TellIso
    extends EntityIso[TellData, Tell] with Def[TellIso] {
    override def from(p: Rep[Tell]) =
      p.msg
    override def to(p: Rep[String]) = {
      val msg = p
      Tell(msg)
    }
    lazy val eFrom = element[String]
    lazy val eTo = new TellElem(self)
    lazy val selfType = new TellIsoElem
    def productArity = 0
    def productElement(n: Int) = ???
  }
  case class TellIsoElem() extends Elem[TellIso] {
    def getDefaultRep = reifyObject(new TellIso())
    lazy val tag = {
      weakTypeTag[TellIso]
    }
    lazy val typeArgs = TypeArgs()
  }
  // 4) constructor and deconstructor
  class TellCompanionAbs extends CompanionDef[TellCompanionAbs] with TellCompanion {
    def selfType = TellCompanionElem
    override def toString = "Tell"

    @scalan.OverloadId("fromFields")
    def apply(msg: Rep[String]): Rep[Tell] =
      mkTell(msg)

    def unapply(p: Rep[Interact[Unit]]) = unmkTell(p)
  }
  lazy val TellRep: Rep[TellCompanionAbs] = new TellCompanionAbs
  lazy val Tell: TellCompanionAbs = proxyTellCompanion(TellRep)
  implicit def proxyTellCompanion(p: Rep[TellCompanionAbs]): TellCompanionAbs = {
    proxyOps[TellCompanionAbs](p)
  }

  implicit case object TellCompanionElem extends CompanionElem[TellCompanionAbs] {
    lazy val tag = weakTypeTag[TellCompanionAbs]
    protected def getDefaultRep = Tell
  }

  implicit def proxyTell(p: Rep[Tell]): Tell =
    proxyOps[Tell](p)

  implicit class ExtendedTell(p: Rep[Tell]) {
    def toData: Rep[TellData] = isoTell.from(p)
  }

  // 5) implicit resolution of Iso
  implicit def isoTell: Iso[TellData, Tell] =
    reifyObject(new TellIso())

  // 6) smart constructor and deconstructor
  def mkTell(msg: Rep[String]): Rep[Tell]
  def unmkTell(p: Rep[Interact[Unit]]): Option[(Rep[String])]

  registerModule(Interactions_Module)
}

// Std -----------------------------------
trait InteractionsStd extends scalan.ScalanDslStd with InteractionsDsl {
  self: InteractionsDslStd =>

  lazy val Interact: Rep[InteractCompanionAbs] = new InteractCompanionAbs {
  }

  case class StdAsk
      (override val prompt: Rep[String])
    extends AbsAsk(prompt) {
  }

  def mkAsk
    (prompt: Rep[String]): Rep[Ask] =
    new StdAsk(prompt)
  def unmkAsk(p: Rep[Interact[String]]) = p match {
    case p: Ask @unchecked =>
      Some((p.prompt))
    case _ => None
  }

  case class StdTell
      (override val msg: Rep[String])
    extends AbsTell(msg) {
  }

  def mkTell
    (msg: Rep[String]): Rep[Tell] =
    new StdTell(msg)
  def unmkTell(p: Rep[Interact[Unit]]) = p match {
    case p: Tell @unchecked =>
      Some((p.msg))
    case _ => None
  }
}

// Exp -----------------------------------
trait InteractionsExp extends scalan.ScalanDslExp with InteractionsDsl {
  self: InteractionsDslExp =>

  lazy val Interact: Rep[InteractCompanionAbs] = new InteractCompanionAbs {
  }

  case class ExpAsk
      (override val prompt: Rep[String])
    extends AbsAsk(prompt)

  object AskMethods {
    object toOper {
      def unapply(d: Def[_]): Option[Rep[Ask]] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[AskElem] && method.getName == "toOper" =>
          Some(receiver).asInstanceOf[Option[Rep[Ask]]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[Ask]] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object AskCompanionMethods {
  }

  def mkAsk
    (prompt: Rep[String]): Rep[Ask] =
    new ExpAsk(prompt)
  def unmkAsk(p: Rep[Interact[String]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: AskElem @unchecked =>
      Some((p.asRep[Ask].prompt))
    case _ =>
      None
  }

  case class ExpTell
      (override val msg: Rep[String])
    extends AbsTell(msg)

  object TellMethods {
    object toOper {
      def unapply(d: Def[_]): Option[Rep[Tell]] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[TellElem] && method.getName == "toOper" =>
          Some(receiver).asInstanceOf[Option[Rep[Tell]]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[Tell]] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object TellCompanionMethods {
  }

  def mkTell
    (msg: Rep[String]): Rep[Tell] =
    new ExpTell(msg)
  def unmkTell(p: Rep[Interact[Unit]]) = p.elem.asInstanceOf[Elem[_]] match {
    case _: TellElem @unchecked =>
      Some((p.asRep[Tell].msg))
    case _ =>
      None
  }

  object InteractMethods {
    object toOper {
      def unapply(d: Def[_]): Option[Rep[Interact[A]] forSome {type A}] = d match {
        case MethodCall(receiver, method, _, _) if receiver.elem.isInstanceOf[InteractElem[_, _]] && method.getName == "toOper" =>
          Some(receiver).asInstanceOf[Option[Rep[Interact[A]] forSome {type A}]]
        case _ => None
      }
      def unapply(exp: Exp[_]): Option[Rep[Interact[A]] forSome {type A}] = exp match {
        case Def(d) => unapply(d)
        case _ => None
      }
    }
  }

  object InteractCompanionMethods {
  }
}

object Interactions_Module extends scalan.ModuleInfo {
  val dump = "H4sIAAAAAAAAALVWTWwbRRQe/yS2Y7dNU2gLUkkwLmn5sSsqVKQIIZMfSOUmVjdpwalajXfH7razs8vO2LU5lFsl4IYQByQORSAuERLigkDiAkgIoR64cubUUlU9UAkJxJvZH69NNgkH9jDanX373vu+9723s/k7GuMuepLrmGJWtojAZU3dV7koaYtMmKJ/xjY6lCyQ1sVXP/5zw3r7UBJNNtD4ZcwXOG2gnHez2HPCe00YNZTDTCdc2C4X6PGailDRbUqJLkybVUzL6gjcpKRSM7mYq6F00zb6b6DrKFFDk7rNdJcIos1TzDnh/n6WyIzM8DmnnvurziAGq0gUlQiKNRebAtKHGJOe/VniaH1ms74l0F4/tVVHpgU2edJzAMOy5VAVJlVDGdNybFcEUTMQ4bJtBI9phmEDTdWu4C6uQNR2RROuydrSmYP1q7hNVsBEmqcBAye0tdZ3iO88z4UxFK/nIISgKs+pxMoDzsohZ2XJWUkjromp+SaWL+uu3esj70qkEOo54OKZHVwEHsgiM0rvXNA3Hmh5Kyk/7slUMiqhcXA0HaMQVR7g9sez7/H7r9w8lUQTDTRh8mqTCxfrIioDn648ZswWKueQQey2oYLFuAqqKFWwGZFJTrctBzPw5HNZgEJRUzeFNJZ7Bb88MdxnhEMC00TPSYR4Z2LwKi3NY0rrtx959uidxdeSKDkcIgcuNWgGN3AqUHaZCSLZCN0/EefeIXXXtEDiXfL8d9+s3/t2ZUxFmDJIC3eoOIdph3jq8uMNYstQyWJRoPGBQa43WDPb4AoZnr191/jhBLqQDOviw9idFMDF1Asffn2U1D9PomxDdc4SxW0lCkn8AuF6A2XtLnG9/UwXU3m3pTAyPmy/XFGeU8CzQDOxTe8QWYQ51UyJAH7e64cVm5HSUr30h/bT+5tS7i4qeG+8KfC3eeqvX/e2hOoE4NNxQWde9fYJlILx4bEhl4e2onnC86bZFtlfvG9evPmuUIQmesNzYrV5BfpyTn332DbcBiPsixs3Hr73yaUDqs2yTVNY2Cmd+A9NFvTE/9hESJEwGB+HBs9ymQZCC1V+dT4adXrUHFgGm5FX+aA//UKM9pVcD0APHDsuUHqdmeLfpVERIuaPhupQsSCsxdu7LrRcS2qd3QXqPWuE0p1gp6XR4J0XLZLwLBrmIAWq2JkV2E5UIw5jiBnBsHto+4OYW8CLDkC1G06SI/FTEPT0+h2jfPjukWtJNH4ajbVgRPAaGmvaHWYEQoVTgiA98XKwlxgWKggTu9gKDw9dDH87aBSBDgZjoyNMWjnn73vDAq4ZNEg/ZA4SPugnLL8qLzPPnyg9/dXmNfPW8SU1LkapnR9gLoGLcgzmBaJT7BJDHgOIBccUr3dPfvDS+dOHz6+r6VEwlJH3Jpx9Wx+qzmBnTh0Bjm1zBACj0iJMtr68Ofn9i7+89fNnn4YoMj7+QlA9L+yeAIHNsMFDYMUYYJo/LECn1x98tPLUrS9/U3+0CTl2YA6z8FgV/ZMNa3dfNAM4K0WUDB0jx1FErxtyufQP9dAdutoKAAA="
}
}

